# 浏览器缓存
> 可以理解为浏览器有一个缓存表，存在资源和请求的对应关系和规则，每次发请求前先去查找有没有缓存，在根据规则使用对应的缓存

优点：  
1. 减少了冗余的数据传递，节省宽带流量
2. 减少了服务器的负担，大大提高了网站性能
3. 加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因
## HTTP 缓存
1. 主要有*强缓存*、*协商缓存*
2. *强缓存*优先级高于*协商缓存*
3. *强缓存*不与服务器通信，即客户端进行判断
4. *协商缓存*与服务器通信，即服务端进行判断

### 强缓存
> 根据响应头中的 *Expires* 和 *Cache-Control* 字段来控制，判断是否命中缓存，如果命中则不予服务器发生通信（灰色 200状态码）

+ *Expires*: `Wed, 11 Sep 2019 16:12:18 GMT`
  + http/1.0 采用绝对时间判断资源是否过期
  + 缺点：因为绝对时间是服务器返回的，浏览器请求的时候会根据浏览器的时间进行对比，对客户端时间与服务器时间之间的一致性提出了极高的要求
+ *cache-control*: `max-age=31536000`
  + http/1.1 采用相对时间（秒）判断资源是否过期
  + 客户端会记录请求的时间作为起始时间，再次请求时获取当前时间与max-age值对比判断
  + 起始时间和当前时间都来源于客户端，判断更准确
+ Cache-Control 的 max-age 配置项相对于 expires 的优先级更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。

#### Cache-Control的其它值
> 值用逗号分隔
+ *s-maxage*: s-maxage仅在代理服务器中生效，客户端中我们只考虑max-age。s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。
+ *public*: 资源能被代理服务器和客户端缓存
+ *private*: 默认值，资源只能被客户端缓存
+ *no-store*: 使用协商缓存
+ *no-cache*: 不使用任何缓存策略

### 协商缓存
> 浏览器需要向服务器送法请求信息询问缓存是否有效，如果有效资源会被重定向到浏览器缓存（304 Not Modified）

#### 通过时间戳，服务器文件最后修改时间
+ *Last-Modified*: 时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回`Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT`
+ *If-Modified-Since*:  后面的请求头会带上这个字段，值正是上一次 response 返回给它的 last-modified 值`If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT`
+ 服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段
+ 缺点：If-Modified-Since只能检测最小为秒单位的时间差、只对比文件最后修改时间，不对比内容

#### 通过唯一的标识字符串，服务器基于文件内容生成的
+ *Etag*: 响应头中，服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的。`ETag: W/"2a3b-1602480f459"`
+ *If-None-Match*: 请求头，每次请求都会带上，值为Etag的值。供服务端比对。`If-None-Match: W/"2a3b-1602480f459"`
+ 缺点：Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能。Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在
+ Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准

### 缓存流程（策略）
> 一般推荐按照这种流程设置缓存策略
#### 强缓存
查看缓存数据库
1. 命中: 缓存未失效返回资源副本（灰色200），不与服务器通信
2. 未命中: 缓存失效，请求服务器，返回资源和缓存规则，浏览器存储资源和缓存规则，供下次使用
3. 

#### 协商缓存
客户端会先从缓存数据库中获取到一个缓存数据的标识（服务器返回的），放在请求头中，服务器判断是否命中
1. 命中: 通知客户端有效（304），客户端从缓存数据库取资源副本
2. 未命中: 返回资源和缓存规则，浏览器存储资源和缓存规则，供下次使用

两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。

### 优先级
cache-control > Expires > Etag > Last-Modified

### 对应关系
+ Expires：服务器返回，浏览器记录
+ cache-control：服务器返回，浏览器记录
+ Last-Modified：服务器返回，浏览器记录，请求带上 If-Modified-Since
+ Etag：服务器返回，浏览器记录，请求带上 If-None-Match

### 判断规则
+ Expires：客户端根据绝对时间判断
  + 值是服务器返回的绝对时间，浏览器根据当前的请求时间判断是否过期，服务器时间和客户端时间。客户端判断
+ cache-control：
  + max-age：客户端根据两次请求相对时间差判断
    + 值为相对时间（秒），浏览器根据这次请求时间和上次请求时间差判断是否过期，客户端时间和客户端时间。客户端判断
  + no-store：直接使用协商缓存
  + no-cache：不使用任何缓存策略
+ Last-Modified：服务端根据文件最后修改时间判断
+ Etag：服务端根据文件是否改动判断

### 更新缓存规则
+ 客户端会更新服务端返回的最新规则和数据到缓存表里

### 刷新规则
+ 输入URL：正常流程
+ 刷新：使用协商缓存
+ 强制刷新：删除缓存文件，重新请求数据

### 其它知识点
+ from Memory Cache: 浏览器缓存到内存的数据，读取快，内存很小，一般会缓存base64、小图片等资源
+ from disk Cache: 浏览器缓存到硬盘的数据，缓存较大的js、css等
+ Push Cache: http2.0特性
  + Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache
  + 存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。
  + 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。
+ Service Worker Cache: 离线缓存，Server Worker 对协议是有要求的，必须以 https 协议为前提