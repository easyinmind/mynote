# 浏览器渲染
> 渲染工作主要是在 *渲染进程* 和 *GPU进程* 中进行的
渲染进程：主线程（html解析器，css解析器，v8）、合成线程、图块栅格化线程
GPU 进程：GPU 线程
## 简述
浏览器并不认识html和css，所以会将html转为dom树，css转为styleSheets，然后结合成布局树，再进行其它的一些操作。整个过程是一个串行的过程，大部分工作都在主线程内处理。中间分为很多阶段，每个阶段都会有一个输入内容和输出内容。
构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

## 概念


## 流程

> 主线程中执行
### 构建 DOM 树
> html => domTree
将html转为浏览器可以识别的dom树
### 样式计算
> css => styleSheets
1. 将css转为浏览器可以识别的结构styleSheets
   1. 外链
   2. 内嵌
   3. 行内
2. 属性值标准化（2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700）
3. 根据继承和层叠规则计算出dom节点中每个元素的具体样式，默认有UserAgent样式

### 布局过程
> domTree/styleSheets => loayoutTree
1. 创建布局树（只包含可见元素，或者可绘制元素）
2. 布局计算（计算出元素的位置）

### 分层
> loayoutTree => layerTree
1. 特定节点生成专用图层，生成一棵图层树（层叠上下文、Clip，类似 PhotoShop 里的图层）；
2. 拥有层叠上下文属性（明确定位属性、透明属性、CSS 滤镜、z-index 等）的元素会创建单独图层；
3. 没有图层的 DOM 节点属于父节点图层；
4. 需要剪裁的地方也会创建图层。（overflow）

### 绘制
> layerTree => 图层绘制指令列表  
> 每个layer（图层）对应一个列表
1. 输入：图层树；
2. 渲染引擎对图层树中每个图层进行绘制；
3. 拆分成绘制指令，生成绘制列表，提交到合成线程；
4. 输出：绘制列表。

> 下面是在合成线程中执行
### 分块
> 图层 => 图块
合成线程会将图层（一屏显示不完，大部分不在视口内）划分为图块（tile, 256*256, 512*512）。

### 栅格化
> 图块 => 位图  
1. 栅格化：将图块转化为位图（位图在cpu内存）
2. 快速栅格化：使用GPU 生成位图的过程（位图在gpu内存）
3. 渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的
4. 合成线程会优先为 *视口* 附近的图块生成位图


### 合成显示
> 位图 => 页面
所有图块被栅格化之后，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。


## 关于交互
1. 浏览器进程接收触发的事件，将事件目标和事件类型发送给渲染进程的合成线程
2. 合成线程根据事件目标来运行注册的监听程序


## 重排重绘合成
1. 构建DOM树 =》主线程
2. 计算样式 =》主线程
3. Layout布局 =》主线程 =》 重排触发
4. Layer分层 =》主线程 =》 重排触发
5. paint绘制命令 =》主线程 =》 重排触发 =》 重绘触发
6. 分块 =》合成线程 =》 重排触发 =》 重绘触发 =》 合成触发
7. 栅格化 =》合成线程 =》 重排触发 =》 重绘触发 =》 合成触发
8. 合成 =》合成线程 =》 重排触发 =》 重绘触发 =》 合成触发

### 优化
减少触发次数
1. 使用class统一改变
2. 批量dom操作使用createDocumentFragment
3. 虚拟dom计算差异后统一处理

## 关于css、js阻塞问题

1. HTML 解析器在解析到 script 标签时，会暂停 DOM 的解析，因为js可能要修改当前已经生成的 DOM 结构。这时候 HTML 解析器暂停工作，JavaScript 引擎介入执行代码，执行完成之后HTML 解析器回复解析过程。（如果js代码没有dom操作，可以使用defer、async属性）
   1. async：下载完就执行（省去了下载时间），不确定执行顺序
   2. defer：DOMContentLoaded事件之前执行（即所有资源下载完成），按顺序执行
2. js下载过程会阻塞 DOM解析，不过 Chrome 做了 *预解析操作*，渲染引擎接收到字节流后悔开启一个预解析线程分析HTML中的js、css，提前下载这些文件
3. 如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。
```html
<html>
    <head>
        <style src='theme.css'></style>
    </head>
<body>
    <div>1</div>
    <script>
        let div1 = document.getElementsByTagName('div')[0]
        div1.innerText = 'time.geekbang' //需要DOM
        div1.style.color = 'red'  //需要CSSOM
    </script>
    <div>test</div>
</body>
</html>
```
而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本

总结：  
1. CSS不阻塞dom的生成。
2. CSS不阻塞js的加载，但是会阻塞js的执行。
3. js会阻塞dom的生成，也就是会阻塞页面的渲染，那么css也有可能会阻塞页面的渲染。
